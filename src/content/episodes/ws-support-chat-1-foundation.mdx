---
title: "WebSocket 客服聊天系统（I）：从 HTTP Upgrade 到可认证的 WS 骨架"
date: "2025-12-15"
episode: "E04"
cover: "/covers/ws-support-chat-1.jpg"
description: "从零可复现的小 Demo：用 Node.js + ws + TypeScript 搭一个可扩展的客服聊天 WebSocket 骨架，包含协议、JWT 鉴权、连接状态机与基础错误处理。"
tags:
  - websocket
  - nodejs
  - typescript
  - system-design
  - chat
---

## 大纲

- 目标与边界：这一部只做“连得上 + 鉴权正确 + 状态可观测”
- Demo 项目结构：最小文件夹 + 最少依赖先跑起来
- WS 基础骨架：HTTP Upgrade → `ws` 处理连接
- 协议最小闭环：`hello` / `auth` / `auth_ok` / `error` / `ping` / `pong`
- 可复现验证：用 `curl` 拿 token，用 `wscat` 连 WS

## 背景

WebSocket 教程最常见的坑不是“连不上”，而是“连上以后架构立刻崩掉”：

- 没有协议边界，什么都往一个 `onmessage` 里塞
- 没有鉴权状态机，导致未认证也能发业务消息
- 没有错误码与重试语义，客户端只能“随缘重连”

所以第一部不急着做聊天业务，我们先把 **WS 的骨架搭稳**：让它能被复用、能扩展、能检查。

---

## 0. 目标与非目标（可检查的前提）

### 目标

1. 你能启动一个 HTTP 服务，并在 `/ws/chat` 升级为 WebSocket
2. 你能拿到一个可用的 JWT，并完成 WS 鉴权
3. 你能清晰地区分 “未认证连接” 与 “已认证连接”
4. 你能用 `ping/pong` 验证连接活着

### 非目标（这一部不做）

- 不做会话/消息/图片
- 不做限流/排队/幂等（第三部做）
- 不做多实例一致性（只讨论单实例 demo）

---

## 1. 初始化一个最小可跑的 Demo 项目

你可以新建一个文件夹（名字随意，这里叫 `ws-support-chat-demo/`）：

```
ws-support-chat-demo/
  package.json
  tsconfig.json
  src/
    index.ts
    config.ts
    ws/
      protocol.ts
      auth.ts
      server.ts
```

### 1.1 安装依赖

```bash
mkdir ws-support-chat-demo && cd ws-support-chat-demo
npm init -y

npm i express ws jsonwebtoken
npm i -D typescript tsx @types/node @types/express @types/jsonwebtoken @types/ws
```

### 1.2 `package.json` 脚本

**文件：`package.json`**

```json
{
  "name": "ws-support-chat-demo",
  "private": true,
  "scripts": {
    "dev": "tsx watch src/index.ts",
    "start": "node dist/index.js",
    "build": "tsc -p tsconfig.json"
  }
}
```

### 1.3 TypeScript 配置

**文件：`tsconfig.json`**

```json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "CommonJS",
    "moduleResolution": "Node",
    "outDir": "dist",
    "rootDir": "src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true
  }
}
```

---

## 2. 定义一份“最小可扩展”的 WS 协议

这一部我们先把协议压到最小闭环：**能握手、能鉴权、能心跳、能报错**。

**文件：`src/ws/protocol.ts`**

```ts
export type ClientType = 'customer' | 'agent';

export type UserDTO = {
  id: number;
  name: string;
  role: ClientType;
};

export type ClientToServer =
  | { type: 'auth'; token: string }
  | { type: 'ping'; ts?: number };

export type ServerToClient =
  | { type: 'hello'; required: Array<'auth'> }
  | { type: 'auth_ok'; user: UserDTO }
  | { type: 'pong'; ts: number }
  | { type: 'error'; code: string; message: string; retry_after_ms?: number };
```

**设计点**：

- `type` 是唯一分发入口，后续扩协议只新增 union 成员
- `error` 必须带 `code`：客户端才能做可预测的处理（提示/重试/停止重连）

---

## 3. JWT：只做“可复现的鉴权”，不做账号系统

为了让 Demo 可复现，我们提供一个 “开发登录” 接口来签发 token（真实项目里你会用自己的登录系统替换它）。

**文件：`src/ws/auth.ts`**

```ts
import jwt from 'jsonwebtoken';
import type { SignOptions } from 'jsonwebtoken';
import type { ClientType, UserDTO } from './protocol';

export type JwtPayload = {
  userId: number;
  role: ClientType;
};

export function signToken(params: {
  secret: string;
  userId: number;
  role: ClientType;
  expiresIn: NonNullable<SignOptions['expiresIn']>;
}) {
  const payload: JwtPayload = { userId: params.userId, role: params.role };
  return jwt.sign(payload, params.secret, { expiresIn: params.expiresIn });
}

export function verifyToken(params: { secret: string; token: string }): JwtPayload | null {
  try {
    return jwt.verify(params.token, params.secret) as JwtPayload;
  } catch {
    return null;
  }
}

export function loadUser(payload: JwtPayload): UserDTO {
  // Demo 版：把 userId 映射成一个简单用户对象
  const name = payload.role === 'agent' ? `Agent#${payload.userId}` : `Customer#${payload.userId}`;
  return { id: payload.userId, name, role: payload.role };
}
```

---

## 4. WS Server：连接状态机 + 基础错误处理

**文件：`src/ws/server.ts`**

```ts
import { WebSocketServer, WebSocket } from 'ws';
import type { IncomingMessage } from 'http';
import type { ClientToServer, ServerToClient, UserDTO } from './protocol';
import { loadUser, verifyToken } from './auth';

type ClientState = {
  ws: WebSocket;
  authenticated: boolean;
  user: UserDTO | null;
};

function safeJsonParse(text: string): unknown {
  try {
    return JSON.parse(text);
  } catch {
    return null;
  }
}

function send(ws: WebSocket, payload: ServerToClient) {
  if (ws.readyState !== WebSocket.OPEN) return;
  try {
    ws.send(JSON.stringify(payload));
  } catch {
    // ignore
  }
}

function sendError(ws: WebSocket, message: string, code = 'BAD_REQUEST', extra: Partial<ServerToClient> = {}) {
  send(ws, { type: 'error', code, message, ...(extra as any) });
}

export function createChatWsServer(params: { jwtSecret: string }) {
  const wss = new WebSocketServer({ noServer: true, maxPayload: 1_000_000 });
  const wsToState = new Map<WebSocket, ClientState>();

  async function handleAuth(ws: WebSocket, token: string) {
    const payload = verifyToken({ secret: params.jwtSecret, token });
    if (!payload) {
      sendError(ws, 'token 无效或已过期', 'UNAUTHORIZED');
      ws.close();
      return;
    }

    const state = wsToState.get(ws);
    if (!state) return;

    state.user = loadUser(payload);
    state.authenticated = true;
    send(ws, { type: 'auth_ok', user: state.user });
  }

  wss.on('connection', (ws: WebSocket, _req: IncomingMessage) => {
    wsToState.set(ws, { ws, authenticated: false, user: null });
    send(ws, { type: 'hello', required: ['auth'] });

    ws.on('message', async (data) => {
      const text = typeof data === 'string' ? data : data.toString();
      const msg = safeJsonParse(text) as ClientToServer | null;

      if (!msg || typeof (msg as any).type !== 'string') {
        sendError(ws, '消息格式错误');
        return;
      }

      if (msg.type === 'auth') {
        const token = typeof msg.token === 'string' ? msg.token : '';
        if (!token) return sendError(ws, 'token 不能为空');
        await handleAuth(ws, token);
        return;
      }

      const state = wsToState.get(ws);
      if (!state || !state.authenticated) {
        sendError(ws, '未认证', 'UNAUTHORIZED');
        return;
      }

      if (msg.type === 'ping') {
        send(ws, { type: 'pong', ts: Date.now() });
        return;
      }

      sendError(ws, '未知消息类型');
    });

    ws.on('close', () => {
      wsToState.delete(ws);
    });

    ws.on('error', () => {
      wsToState.delete(ws);
    });
  });

  return wss;
}
```

**你应该注意到**：

- 一切业务消息都在 `authenticated === true` 之后才允许处理
- `maxPayload` 是你最早应该加的安全阀之一（避免超大包打爆内存）

---

## 5. HTTP Server：负责 Upgrade 与“开发登录”

**文件：`src/config.ts`**

```ts
export function getConfig() {
  const port = Math.max(1, Number(process.env.PORT || 3000));
  const jwtSecret = String(process.env.JWT_SECRET || 'dev-secret-change-me');
  return { port, jwtSecret };
}
```

**文件：`src/index.ts`**

```ts
import http from 'http';
import express from 'express';
import { WebSocket } from 'ws';
import { createChatWsServer } from './ws/server';
import { getConfig } from './config';
import { signToken } from './ws/auth';

const config = getConfig();
const app = express();
app.use(express.json());

app.get('/health', (_req, res) => res.json({ ok: true }));

// Demo：开发登录，签发 token（真实项目请替换）
app.post('/api/dev/login', (req, res) => {
  const role = req.body?.role === 'agent' ? 'agent' : 'customer';
  const userId = Math.max(1, Number(req.body?.userId || 1));
  const token = signToken({ secret: config.jwtSecret, userId, role, expiresIn: '7d' });
  res.json({ token, role, userId });
});

const server = http.createServer(app);
const wss = createChatWsServer({ jwtSecret: config.jwtSecret });

server.on('upgrade', (req, socket, head) => {
  try {
    const base = `http://${req.headers.host || 'localhost'}`;
    const url = new URL(req.url || '/', base);
    if (url.pathname !== '/ws/chat') return;

    wss.handleUpgrade(req, socket, head, (ws: WebSocket) => {
      wss.emit('connection', ws, req);
    });
  } catch {
    socket.destroy();
  }
});

server.listen(config.port, () => {
  // eslint-disable-next-line no-console
  console.log(`[dev] http://localhost:${config.port}`);
  // eslint-disable-next-line no-console
  console.log(`[dev] ws://localhost:${config.port}/ws/chat`);
});
```

---

## 6. 可复现验证（你应该能“看到它工作”）

### 6.1 启动服务

```bash
npm run dev
```

### 6.2 拿到一个 customer token

```bash
curl -s http://localhost:3000/api/dev/login \
  -H 'content-type: application/json' \
  -d '{"role":"customer","userId":1}'
```

### 6.3 用 `wscat` 连上 WS 并鉴权

```bash
npx wscat -c ws://localhost:3000/ws/chat
```

连接后你会先收到 `hello`，然后发送：

```json
{ "type": "auth", "token": "<paste-token-here>" }
```

预期你会收到：

```json
{ "type": "auth_ok", "user": { "id": 1, "name": "Customer#1", "role": "customer" } }
```

再发一个心跳：

```json
{ "type": "ping" }
```

预期收到 `pong`。

---

## 下一步

第二部我们会在这个骨架上加入“聊天的真实业务闭环”：会话、消息、历史拉取，以及图片上传的链路（HTTP 上传 → URL → WS 发消息）。
